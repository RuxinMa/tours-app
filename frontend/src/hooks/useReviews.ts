import { useCallback } from 'react';
import { useAppDispatch, useAppSelector } from './redux';
import { reviewsService, ReviewsError } from '../services/reviewsService';
import {
  setLoading,
  setSubmitting,
  setError,
  clearError,
  setTourReviews,
  setUserReviews,
  addUserReview,
  updateUserReview,
  removeUserReview,
  setCurrentReview,
  clearCurrentReview,
  clearTourReviews,
} from '../store/slices/reviewsSlice';
import { updateUserBookingStatus } from '../store/slices/bookingsSlice';
import type { CreateReviewData, UpdateReviewData, Review, ReviewWithTourInfo } from '../types/review';
import type { ReviewSubmitData } from '../components/common/ReviewModal';

export const useReviews = () => {
  const dispatch = useAppDispatch();
  
  // Select state from Redux
  const reviewsState = useAppSelector((state) => state.reviews);
  const toursState = useAppSelector((state) => state.tours);
  const bookingsState = useAppSelector((state) => state.bookings);

  // üìÑ Helper function to find booking by tour ID
  const findBookingByTourId = useCallback((tourId: string) => {
    return bookingsState.userBookings.find(booking => booking.tourId === tourId);
  }, [bookingsState.userBookings]);

  // üìñ Load reviews for a specific tour (Tour Detail Page)
  const loadTourReviews = useCallback(async (tourId: string) => {
    // Check if already loaded
    if (reviewsState.tourReviews[tourId]?.length > 0) {
      console.log(`üìÑ Reviews already loaded for tour ${tourId}`);
      return { success: true };
    }

    dispatch(setLoading(true));
    dispatch(clearError());

    try {
      console.log(`üìÑ useReviews: Loading reviews for tour ${tourId}...`);
      
      const reviews = await reviewsService.fetchTourReviews(tourId);
      
      dispatch(setTourReviews({ tourId, reviews }));
      dispatch(setLoading(false));
      
      console.log(`‚úÖ useReviews: Successfully loaded ${reviews.length} reviews for tour ${tourId}`);
      return { success: true };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to load reviews for tour ${tourId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to load reviews. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setLoading(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.tourReviews]);

  // üë§ Load user's own reviews (User Profile Page)
  const loadUserReviews = useCallback(async () => {
    dispatch(setLoading(true));
    dispatch(clearError());

    try {
      console.log('üìÑ useReviews: Loading user reviews...');
      
      const reviews = await reviewsService.fetchUserReviews();
      
      dispatch(setUserReviews(reviews));
      dispatch(setLoading(false));
      
      console.log(`‚úÖ useReviews: Successfully loaded ${reviews.length} user reviews`);
      return { success: true };
      
    } catch (error) {
      console.error('üö® useReviews: Failed to load user reviews:', error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to load your reviews. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setLoading(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch]);

  // ‚úèÔ∏è Create a new review (WITH BOOKING COORDINATION)
  const createReview = useCallback(async (reviewData: CreateReviewData) => {

    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log('‚úèÔ∏è useReviews: Creating new review...', reviewData);
      
      // 1Ô∏è‚É£ Create the review
      const newReview = await reviewsService.createReview(reviewData);
      
      // 2Ô∏è‚É£ Update local review state
      dispatch(addUserReview(newReview));
      
      // 3Ô∏è‚É£ Cross-domain coordination: Update booking status to 'reviewed'
      const booking = findBookingByTourId(reviewData.tour);
      if (booking && booking.status === 'pending-review') {
        console.log(`üìÑ useReviews: Updating booking ${booking.id} status to 'reviewed'`);
        dispatch(updateUserBookingStatus({ 
          bookingId: booking.id, 
          status: 'reviewed' 
        }));

        // Also update backend booking status
        try {
          const { bookingsService } = await import('../services/bookingsService');
          await bookingsService.updateBookingStatus(booking.id, 'reviewed');
          console.log('‚úÖ useReviews: Successfully updated booking status in backend');
        } catch (bookingError) {
          console.warn('‚ö†Ô∏è useReviews: Failed to update booking status in backend:', bookingError);
        }
      }
      
      // 4Ô∏è‚É£ If tour reviews are loaded, refresh them to show the new review
      if (reviewsState.tourReviews[reviewData.tour]) {
        const currentTourReviews = reviewsState.tourReviews[reviewData.tour];
        dispatch(setTourReviews({ 
          tourId: reviewData.tour, 
          reviews: [...currentTourReviews, newReview] 
        }));
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully created review and updated booking status');
      return { success: true, review: newReview };
      
    } catch (error) {
      console.error('üö® useReviews: Failed to create review:', error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to create review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [reviewsState.tourReviews, dispatch, findBookingByTourId]);

  // üìù Update an existing review - ENHANCED VERSION
  const updateReview = useCallback(async (reviewId: string, updateData: UpdateReviewData) => {
    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log(`üìù useReviews: Updating review ${reviewId}...`, updateData);
      
      const updatedReview = await reviewsService.updateReview(reviewId, updateData);
      
      // Update in user reviews
      dispatch(updateUserReview(updatedReview));
      
      // Update current review if it's the same one
      if (reviewsState.currentReview?.id === reviewId) {
        dispatch(setCurrentReview(updatedReview));
      }
      
      // Refresh tour reviews if they're loaded
      if (reviewsState.tourReviews[updatedReview.tour]) {
        const currentTourReviews = reviewsState.tourReviews[updatedReview.tour];
        const updatedTourReviews = currentTourReviews.map(review => 
          review.id === reviewId ? updatedReview : review
        );
        dispatch(setTourReviews({ 
          tourId: updatedReview.tour, 
          reviews: updatedTourReviews 
        }));
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully updated review');
      return { success: true, review: updatedReview };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to update review ${reviewId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to update review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.currentReview, reviewsState.tourReviews]);

  // üîß Enhanced update review with UI coordination
  const updateReviewAndRefresh = useCallback(async (reviewId: string, updateData: UpdateReviewData) => {
    const result = await updateReview(reviewId, updateData);
    
    if (result.success) {
      // Force refresh user reviews to ensure UI is up to date
      try {
        await loadUserReviews();
        console.log('‚úÖ User reviews refreshed after update');
      } catch (refreshError) {
        console.warn('‚ö†Ô∏è Failed to refresh user reviews after update:', refreshError);
      }
    }
    
    return result;
  }, [updateReview, loadUserReviews]);

  // üîß Handle edit review submit (for component)
  const handleEditReviewSubmit = useCallback(async (data: ReviewSubmitData) => {
    if (!data.reviewId) {
      return { success: false, error: 'Review ID is required' };
    }

    try {
      // Clear any existing errors
      dispatch(clearError());
      
      const result = await updateReviewAndRefresh(data.reviewId, {
        rating: data.rating,
        review: data.review,
        updatedAt: new Date().toISOString()
      });

      if (result.success) {
        // Clear current review selection
        dispatch(clearCurrentReview());
        console.log('‚úÖ Edit review completed successfully');
      }

      return result;
    } catch (error) {
      console.error('üö® Error in handleEditReviewSubmit:', error);
      return { success: false, error: 'Failed to update review. Please try again.' };
    }
  }, [dispatch, updateReviewAndRefresh]);

  // üóëÔ∏è Delete a review (WITH BOOKING COORDINATION)
  const deleteReview = useCallback(async (reviewId: string) => {
    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log(`üóëÔ∏è useReviews: Deleting review ${reviewId}...`);
      
      // 1Ô∏è‚É£ Find the review to get tour ID before deletion
      const reviewToDelete = reviewsState.userReviews.find(r => r.id === reviewId);
      
      if (!reviewToDelete) {
        throw new ReviewsError('Review not found in local state');
      }
      
      // 2Ô∏è‚É£ Delete the review
      await reviewsService.deleteReview(reviewId);
      
      // 3Ô∏è‚É£ Remove from user reviews
      dispatch(removeUserReview(reviewId));
      
      // 4Ô∏è‚É£ üìÑ Cross-domain coordination: Update booking status back to 'pending-review'
      const booking = findBookingByTourId(reviewToDelete.tour);
      if (booking && booking.status === 'reviewed') {
        console.log(`üìÑ useReviews: Updating booking ${booking.id} status back to 'pending-review'`);
        dispatch(updateUserBookingStatus({ 
          bookingId: booking.id, 
          status: 'pending-review' 
        }));
        
        // üìÑ Also update backend booking status
        try {
          const { bookingsService } = await import('../services/bookingsService');
          await bookingsService.updateBookingStatus(booking.id, 'pending-review');
          console.log('‚úÖ useReviews: Successfully updated booking status in backend');
        } catch (bookingError) {
          console.warn('‚ö†Ô∏è useReviews: Failed to update booking status in backend:', bookingError);
        }
      }
      
      // 5Ô∏è‚É£ Clear current review if it's the same one
      if (reviewsState.currentReview?.id === reviewId) {
        dispatch(clearCurrentReview());
      }
      
      // 6Ô∏è‚É£ Refresh tour reviews if they're loaded
      if (reviewsState.tourReviews[reviewToDelete.tour]) {
        console.log('üîÑ Refreshing tour reviews after deletion');
        dispatch(clearTourReviews(reviewToDelete.tour));
        await loadTourReviews(reviewToDelete.tour);
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully deleted review and updated booking status');
      return { success: true };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to delete review ${reviewId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to delete review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.userReviews, reviewsState.currentReview, reviewsState.tourReviews, loadTourReviews, findBookingByTourId]);

  // üîß Handle delete review with UI coordination
  const handleDeleteReview = useCallback(async (reviewId: string) => {
    const result = await deleteReview(reviewId);
    
    if (result.success) {
      // Force refresh user reviews to ensure UI is up to date
      try {
        await loadUserReviews();
        console.log('‚úÖ User reviews refreshed after deletion');
      } catch (refreshError) {
        console.warn('‚ö†Ô∏è Failed to refresh user reviews after deletion:', refreshError);
      }
    }
    
    return result;
  }, [deleteReview, loadUserReviews]);

  // üîÑ Refresh operations
  const refreshTourReviews = useCallback(async (tourId: string) => {
    console.log(`üîÑ useReviews: Refreshing reviews for tour ${tourId}...`);
    dispatch(clearTourReviews(tourId));
    return await loadTourReviews(tourId);
  }, [dispatch, loadTourReviews]);

  const refreshUserReviews = useCallback(async () => {
    console.log('üîÑ useReviews: Refreshing user reviews...');
    dispatch(setUserReviews([]));
    return await loadUserReviews();
  }, [dispatch, loadUserReviews]);

  // üéØ Data getters with tour info enhancement
  const getTourReviews = useCallback((tourId: string): Review[] => {
    return reviewsState.tourReviews[tourId] || [];
  }, [reviewsState.tourReviews]);
  
  // üéØ Get user's reviews with tour info for profile display
  const getUserReviewsWithTourInfo = useCallback((): ReviewWithTourInfo[] => {
    return reviewsState.userReviews.map(review => {
      // Find tour info from tours state
      const tourInfo = toursState.allTours.find(tour => tour.id === review.tour);
      
      if (tourInfo) {
        return {
          ...review,
          tour: { 
            id: tourInfo.id,
            name: tourInfo.name,
            slug: tourInfo.slug,
            imageCover: tourInfo.imageCover
          }
        };
      }
      
      // If tour info not found, return review with default tour info
      return {
        ...review,
        tour: {
          id: review.tour,
          name: 'Unknown Tour',
          slug: '',
          imageCover: 'default-tour.jpg'
        }
      };
    });
  }, [reviewsState.userReviews, toursState.allTours]);

  // üîß Helper functions
  const hasUserReviewedTour = useCallback((tourId: string): boolean => {
    return reviewsState.userReviews.some(review => review.tour === tourId);
  }, [reviewsState.userReviews]);

  const clearReviewsError = useCallback(() => {
    dispatch(clearError());
  }, [dispatch]);

  const selectReview = useCallback((review: Review) => {
    console.log('üéØ Selecting review:', review.id);
    dispatch(setCurrentReview(review));
  }, [dispatch]);

  const clearSelectedReview = useCallback(() => {
    console.log('üéØ Clearing selected review');
    dispatch(clearCurrentReview());
  }, [dispatch]);

  return {
    // üìä State
    tourReviews: reviewsState.tourReviews,
    userReviews: reviewsState.userReviews,
    currentReview: reviewsState.currentReview,
    isLoading: reviewsState.isLoading,
    isSubmitting: reviewsState.isSubmitting,
    error: reviewsState.error,
    
    // üìñ Data Loading
    loadTourReviews,          
    loadUserReviews,          
    refreshTourReviews,
    refreshUserReviews,
    
    // ‚úèÔ∏è CRUD Operations (üìÑ WITH BOOKING COORDINATION)
    createReview,             
    updateReview,
    updateReviewAndRefresh,   // Enhanced version with UI refresh
    deleteReview,             
    
    // üîß Component Helpers (NEW)
    handleEditReviewSubmit,   // Handle complete edit flow
    handleDeleteReview,       // Handle complete delete flow
    
    // üéØ Data Getters
    getTourReviews,           
    getUserReviewsWithTourInfo, 

    // üîß Helper Functions
    hasUserReviewedTour,      
    selectReview,
    clearSelectedReview,
    clearError: clearReviewsError,
  };
};